# Verify Dockerfile REFRESHED_AT Updated
#
# This reusable workflow ensures that when Dockerfiles are modified, all REFRESHED_AT
# environment variables within those files are also updated. This prevents stale Docker
# layer caching by forcing image rebuilds when dependencies change.
#
# ## How it works:
# 1. Detects which Dockerfiles have been modified in a pull request
# 2. Compares REFRESHED_AT values between the base and head commits
# 3. Fails the check if any REFRESHED_AT values remain unchanged
# 4. Automatically skips for commits authored by Renovate bot
#
# ## Usage:
# ```yaml
# jobs:
#   verify-dockerfiles:
#     uses: ./.github/workflows/verify-dockerfile-refreshed.yml
#     with:
#       base-sha: ${{ github.event.pull_request.base.sha }}
#       head-sha: ${{ github.event.pull_request.head.sha }}
#     permissions:
#       contents: read
# ```
#
# ## Inputs:
# - base-sha: (optional) Base commit SHA to compare against
#   - Defaults to github.event.pull_request.base.sha
# - head-sha: (optional) Head commit SHA to compare
#   - Defaults to github.event.pull_request.head.sha
#
# ## Outputs:
# - dockerfiles-changed: Boolean indicating if any Dockerfiles were modified
# - check-status: Result of the check (success/failure/skipped)
#
# ## Behavior:
# - Skips automatically for Renovate bot commits
# - Runs for human commits on Renovate PRs
# - Checks all files matching: **/Dockerfile* and **/package.Dockerfile
# - Compares REFRESHED_AT values by content, not line numbers
# - Allows new REFRESHED_AT additions without requiring updates
#
# ## Example REFRESHED_AT usage in Dockerfile:
# ```dockerfile
# ARG REFRESHED_AT=2024-11-19T10:30:00Z
# RUN apt-get update && apt-get install -y package
# ```

name: Verify Dockerfile REFRESHED_AT Updated

on:
  workflow_call:
    inputs:
      base-sha:
        description: "Base commit SHA to compare against"
        type: string
        required: false
        default: ""
      head-sha:
        description: "Head commit SHA to compare"
        type: string
        required: false
        default: ""
    outputs:
      dockerfiles-changed:
        description: "Whether any Dockerfiles were modified"
        value: ${{ jobs.detect-changes.outputs.dockerfiles }}
      check-status:
        description: "Result of the check (success/failure/skipped)"
        value: ${{ jobs.dockerfile-check-complete.outputs.status }}

permissions: {}

jobs:
  detect-changes:
    name: Detect Dockerfile Changes
    outputs:
      dockerfiles: ${{ steps.filter.outputs.dockerfiles }}
    permissions:
      contents: read
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v5
        with:
          persist-credentials: false

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            dockerfiles:
              - '**/Dockerfile*'
              - '**/package.Dockerfile'

  check-refreshed-at:
    name: Check REFRESHED_AT in Dockerfiles
    permissions:
      contents: read
    runs-on: ubuntu-latest
    needs: detect-changes

    # Skip only if no Dockerfiles changed OR if the actor is Renovate
    # Using github.actor which is reliable in PR contexts
    if: |
      needs.detect-changes.outputs.dockerfiles == 'true' &&
      github.actor != 'renovate[bot]' &&
      github.actor != 'renovate'

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Get base commit
        id: base
        env:
          INPUT_BASE_SHA: ${{ inputs.base-sha }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha }}
        run: |
          if [ -n "$INPUT_BASE_SHA" ]; then
            echo "base=$INPUT_BASE_SHA" >> "$GITHUB_OUTPUT"
          else
            echo "base=$PR_BASE_SHA" >> "$GITHUB_OUTPUT"
          fi

      - name: Get head commit
        id: head
        env:
          INPUT_HEAD_SHA: ${{ inputs.head-sha }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          if [ -n "$INPUT_HEAD_SHA" ]; then
            echo "head=$INPUT_HEAD_SHA" >> "$GITHUB_OUTPUT"
          else
            echo "head=$PR_HEAD_SHA" >> "$GITHUB_OUTPUT"
          fi

      - name: Find modified Dockerfiles
        id: find-dockerfiles
        env:
          BASE_SHA: ${{ steps.base.outputs.base }}
          HEAD_SHA: ${{ steps.head.outputs.head }}
        run: |
          # Find all modified Dockerfiles and package.Dockerfile files
          MODIFIED_DOCKERFILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep -E '(Dockerfile.*|package\.Dockerfile)$' || true)

          if [ -z "$MODIFIED_DOCKERFILES" ]; then
            echo "[INFO] No Dockerfiles modified"
            echo "dockerfiles=" >> "$GITHUB_OUTPUT"
          else
            echo "[INFO] Modified Dockerfiles:"
            echo "[INFO] $MODIFIED_DOCKERFILES"
            # Convert to JSON array with error handling
            if ! DOCKERFILES_JSON=$(echo "$MODIFIED_DOCKERFILES" | jq -R -s -c 'split("\n") | map(select(length > 0))'); then
              echo "::error::[ERROR] Failed to parse Dockerfile list with jq"
              exit 1
            fi
            # Validate JSON output
            if [ -z "$DOCKERFILES_JSON" ] || [ "$DOCKERFILES_JSON" = "null" ]; then
              echo "::error::[ERROR] Invalid JSON output from jq"
              exit 1
            fi
            echo "dockerfiles=$DOCKERFILES_JSON" >> "$GITHUB_OUTPUT"
          fi

      - name: Check REFRESHED_AT updates
        env:
          BASE_SHA: ${{ steps.base.outputs.base }}
          DOCKERFILES: ${{ steps.find-dockerfiles.outputs.dockerfiles }}
        if: steps.find-dockerfiles.outputs.dockerfiles != ''
        run: |
          # Exit on error, undefined variables, and pipeline failures
          # -e: exit on error
          # -u: treat unset variables as error
          # -o pipefail: pipeline fails if any command fails
          set -euo pipefail

          CHECK_FAILED=0
          FAILED_FILES=()

          # Process each Dockerfile from the JSON array
          # Using process substitution to avoid subshell variable scope issues
          while IFS= read -r dockerfile; do
            echo "================================================"
            echo "Checking: $dockerfile"
            echo "================================================"

            # Security: Validate path doesn't contain directory traversal
            if [[ "$dockerfile" =~ \.\. ]]; then
              echo "::error file=${dockerfile}::[ERROR] Invalid path (contains ..): $dockerfile"
              CHECK_FAILED=1
              FAILED_FILES+=("$dockerfile (invalid path)")
              continue
            fi

            # Validate file exists before processing
            if [ ! -f "$dockerfile" ]; then
              echo "::error file=${dockerfile}::[ERROR] File does not exist: $dockerfile"
              CHECK_FAILED=1
              FAILED_FILES+=("$dockerfile (file not found)")
              continue
            fi

            # Check if file has REFRESHED_AT lines, skip if none found
            if ! grep -q "REFRESHED_AT=" "$dockerfile" 2>/dev/null; then
              echo "[INFO] No REFRESHED_AT lines found in $dockerfile (skipping)"
              continue
            fi

            # Get all REFRESHED_AT lines from current version and sort for comparison
            # Using || true to prevent exit on empty result (grep returns 1 when no matches)
            CURRENT_LINES=$(grep "REFRESHED_AT=" "$dockerfile" | sort || true)

            if [ -z "$CURRENT_LINES" ]; then
              echo "[INFO] No REFRESHED_AT lines in current version"
              continue
            fi

            echo "[INFO] Found REFRESHED_AT lines in current version:"
            # Use printf for safe output formatting with proper line prefix
            printf '%s\n' "$CURRENT_LINES" | sed 's/^/[INFO] /'
            echo ""

            # Get the old version of the file from git history
            # Fail gracefully if file is new or git command fails
            if ! OLD_CONTENT=$(git show "$BASE_SHA:$dockerfile" 2>/dev/null); then
              echo "[INFO] New Dockerfile (no previous version to compare)"
              continue
            fi

            # Get all REFRESHED_AT lines from old version (sorted for comparison)
            OLD_LINES=$(echo "$OLD_CONTENT" | grep "REFRESHED_AT=" | sort || true)

            if [ -z "$OLD_LINES" ]; then
              echo "[INFO] REFRESHED_AT lines are new additions"
              continue
            fi

            echo "[INFO] REFRESHED_AT lines in previous version:"
            printf '%s\n' "$OLD_LINES" | sed 's/^/[INFO] /'
            echo ""

            # Compare the sets of REFRESHED_AT values
            # We check if any current lines exist unchanged in the old version
            ALL_MODIFIED=true
            UNCHANGED_LINES=()

            # Read each current REFRESHED_AT line and check against old version
            # Using <<< heredoc to avoid subshell issues with pipes
            while IFS= read -r current_line; do
              # Use grep -Fxq for exact fixed-string matching:
              # -F: treat as fixed string (no regex)
              # -x: match whole lines only
              # -q: quiet mode (exit status only)
              if echo "$OLD_LINES" | grep -Fxq "$current_line"; then
                ALL_MODIFIED=false
                UNCHANGED_LINES+=("$current_line")
              fi
            done <<< "$CURRENT_LINES"

            # Report error if any REFRESHED_AT lines were not updated
            if [ "$ALL_MODIFIED" = false ]; then
              echo "::error file=${dockerfile}::[ERROR] Not all REFRESHED_AT lines were updated in $dockerfile"
              echo "[ERROR]"
              echo "[ERROR] Unchanged lines:"
              # Use printf for safe array output with proper formatting
              printf '[ERROR]   %s\n' "${UNCHANGED_LINES[@]}"
              echo "[ERROR]"
              echo "[ERROR] Please update all REFRESHED_AT values when modifying this Dockerfile."
              CHECK_FAILED=1
              FAILED_FILES+=("$dockerfile")
            else
              echo "[INFO] All REFRESHED_AT lines were updated in $dockerfile"
            fi

            echo ""
          done < <(echo "$DOCKERFILES" | jq -r '.[]')

          # Exit with error if any file failed validation
          # Check against 1 specifically for clarity
          if [ "$CHECK_FAILED" -eq 1 ]; then
            echo "::error::[ERROR] One or more Dockerfiles have unchanged REFRESHED_AT lines"
            echo "[ERROR] Failed files:"
            printf '[ERROR]   - %s\n' "${FAILED_FILES[@]}"
            exit 1
          fi

          echo "::notice::[INFO] All checks passed!"

      - name: Success message
        if: success()
        run: |
          echo "[INFO] All REFRESHED_AT lines have been properly updated"

  dockerfile-check-complete:
    env:
      RESULT: ${{ needs.check-refreshed-at.result }}
    if: always()
    name: Dockerfile Check Status
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    needs: [check-refreshed-at]
    runs-on: ubuntu-latest

    steps:
      - name: Check status
        id: set-status
        run: |
          if [[ "${RESULT}" == "failure" ]]; then
            echo "status=failure" >> "$GITHUB_OUTPUT"
            echo "::error::[ERROR] REFRESHED_AT check failed"
            exit 1
          elif [[ "${RESULT}" == "skipped" ]]; then
            echo "status=skipped" >> "$GITHUB_OUTPUT"
            echo "[INFO] Check skipped - either no Dockerfiles modified or commit by Renovate bot"
            exit 0
          else
            echo "status=success" >> "$GITHUB_OUTPUT"
            echo "[INFO] REFRESHED_AT check passed"
            exit 0
          fi
