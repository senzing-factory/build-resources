name: Link Issues to Pull Request Post Merge

on:
  workflow_call:
    inputs:
      issue-pattern:
        description: "Custom regex pattern for matching issue numbers (optional)"
        required: false
        type: string
        default: '#(\d+)'
      max-commits:
        description: "Maximum number of commits to scan per page (default: 100)"
        required: false
        type: number
        default: 100

permissions: {}

jobs:
  link-issues:
    runs-on: ubuntu-latest

    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Extract Issue Numbers
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title || '';
            const body = pr.body || '';

            let allCommits = [];
            let commitMessagesArray = [];

            try {
              // Fetch commits with pagination support
              const maxCommits = ${{ inputs.max-commits }} || 100;
              let page = 1;
              let hasMore = true;
              
              console.log('=== Fetching commits ===');
              
              while (hasMore && allCommits.length < 250) { // Safety limit: 250 commits max
                const commits = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: maxCommits,
                  page: page
                });
                
                if (commits.data.length === 0) {
                  hasMore = false;
                } else {
                  allCommits = allCommits.concat(commits.data);
                  console.log(`Fetched page ${page}: ${commits.data.length} commits`);
                  
                  // If we got fewer commits than requested, we're on the last page
                  if (commits.data.length < maxCommits) {
                    hasMore = false;
                  } else {
                    page++;
                  }
                }
              }
              
              // Extract commit messages efficiently
              commitMessagesArray = allCommits.map(commit => commit.commit.message);
              
              console.log(`Total commits scanned: ${allCommits.length}`);
              
              if (allCommits.length >= 250) {
                console.log('‚ö†Ô∏è  Warning: Reached 250 commit limit. Some commits may not be scanned.');
              }
              
            } catch (error) {
              console.error('‚ùå Error fetching commits:', error.message);
              console.log('Continuing with PR title and description only...');
              // Continue execution - we'll still search title and body
            }

            // Combine all searchable text efficiently
            const searchParts = [title, body, ...commitMessagesArray];
            const searchText = searchParts.join('\n');

            console.log('=== Searching in ===');
            console.log('PR Title:', title);
            console.log('PR Body length:', body.length, 'chars');
            console.log('Commits scanned:', allCommits.length);
            console.log('---');

            // Validate and sanitize the custom pattern input to prevent ReDoS
            let validatedPattern = '#(\\d+)'; // Safe default
            const customPattern = `${{ inputs.issue-pattern }}`.trim();

            if (customPattern && customPattern !== '#(\\d+)') {
              // Basic validation: ensure pattern doesn't contain dangerous constructs
              const dangerousPatterns = [
                /\(\?\#/,           // Comments that could hide attacks
                /\(\?[<>=!]/,       // Lookaheads/lookbehinds (potential ReDoS)
                /\{[0-9]+,[0-9]*\}\+/, // Nested quantifiers (ReDoS risk)
                /\(\.\*\)\+/,       // Catastrophic backtracking pattern
              ];
              
              let isSafe = true;
              for (const dangerous of dangerousPatterns) {
                if (dangerous.test(customPattern)) {
                  console.log(`‚ö†Ô∏è  Custom pattern contains potentially unsafe construct: ${dangerous}`);
                  isSafe = false;
                  break;
                }
              }
              
              if (isSafe) {
                try {
                  // Test the regex with a timeout simulation
                  new RegExp(customPattern, 'g');
                  validatedPattern = customPattern;
                  console.log('‚úì Using custom issue pattern');
                } catch (e) {
                  console.log(`‚ö†Ô∏è  Invalid custom pattern: ${e.message}. Using default.`);
                }
              } else {
                console.log('‚ö†Ô∏è  Custom pattern rejected for security. Using default.');
              }
            }

            // Pattern for same-repo issues
            const sameRepoRegex = new RegExp(validatedPattern, 'g');

            // Pattern for cross-repo issues: owner/repo#123 or org/repo#123
            // This regex is carefully crafted to avoid ReDoS
            const crossRepoRegex = /\b([a-zA-Z0-9_-]{1,39}\/[a-zA-Z0-9_-]{1,100}#\d{1,10})\b/g;

            // Extract same-repo issues (keep full match including #)
            const sameRepoMatches = [...searchText.matchAll(sameRepoRegex)];
            const sameRepoIssues = sameRepoMatches.map(m => m[0]); // Full match: #123

            // Extract cross-repo issues (keep full match)
            const crossRepoMatches = [...searchText.matchAll(crossRepoRegex)];
            const crossRepoIssues = crossRepoMatches.map(m => m[1]); // Capture group: owner/repo#123

            // Combine and deduplicate
            const allIssues = [...new Set([...sameRepoIssues, ...crossRepoIssues])];

            if (allIssues.length === 0) {
              console.log('‚ùå No issue numbers found in PR title, description, or commit messages');
              console.log('Note: Issue numbers must be prefixed with # (e.g., #123 or owner/repo#123)');
              core.setOutput('found', 'false');
              core.setOutput('issues', '');
              return;
            }

            console.log(`‚úÖ Found ${allIssues.length} issue reference(s):`);
            if (sameRepoIssues.length > 0) {
              console.log(`   Same repo (${sameRepoIssues.length}): ${[...new Set(sameRepoIssues)].join(', ')}`);
            }
            if (crossRepoIssues.length > 0) {
              console.log(`   Cross repo (${crossRepoIssues.length}): ${[...new Set(crossRepoIssues)].join(', ')}`);
            }

            core.setOutput('found', 'true');
            // Use JSON encoding to safely pass issues to next step
            core.setOutput('issues', JSON.stringify(allIssues));

      - name: Update PR Description
        if: steps.extract.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // Safely parse JSON-encoded issues
            let issues = [];
            try {
              const issuesJson = `${{ steps.extract.outputs.issues }}`;
              if (!issuesJson || issuesJson.trim() === '') {
                console.log('‚ö†Ô∏è  No issues data received');
                return;
              }
              issues = JSON.parse(issuesJson);
              
              if (!Array.isArray(issues) || issues.length === 0) {
                console.log('‚ö†Ô∏è  Issues array is empty');
                return;
              }
            } catch (e) {
              console.error('‚ùå Error parsing issues:', e.message);
              core.setFailed(`Failed to parse issues: ${e.message}`);
              return;
            }

            try {
              // Get current PR body
              let body = pr.body || '';
              
              // Enhanced duplicate detection - check for existing "Resolves" sections
              // and also check if these specific issues are already mentioned
              const resolvesHeaderPattern = /^#{1,6}\s*Resolves/mi;
              
              if (resolvesHeaderPattern.test(body)) {
                console.log('‚ö†Ô∏è  PR description already contains a "Resolves" section');
                
                // Check if all our issues are already in the body
                const allIssuesAlreadyPresent = issues.every(issue => {
                  const escapedIssue = issue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                  const issuePattern = new RegExp(`Resolves\\s+${escapedIssue}\\b`, 'i');
                  return issuePattern.test(body);
                });
                
                if (allIssuesAlreadyPresent) {
                  console.log('‚úì All issues already resolved in PR description');
                  return;
                }
                
                console.log('Some new issues to add, but "Resolves" section exists');
                console.log('Skipping to avoid creating duplicate sections');
                return;
              }
              
              // Build the resolves text
              // Issues already have correct format: "#123" or "owner/repo#123"
              const resolvesLines = issues.map(issue => `Resolves ${issue}`);
              const resolvesText = resolvesLines.join('\n');
              
              // Append to existing body with proper spacing
              const separator = body.trim() ? '\n\n---\n\n' : '';
              const updatedBody = `${body}${separator}${resolvesText}`;
              
              // Update the PR
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                body: updatedBody
              });
              
              console.log(`‚úÖ Updated PR #${pr.number} with:`);
              issues.forEach(issue => console.log(`   - Resolves ${issue}`));
              console.log(`üìã Total issues linked: ${issues.length}`);
              
            } catch (error) {
              console.error('‚ùå Error updating PR description:', error.message);
              core.setFailed(`Failed to update PR: ${error.message}`);
            }

      - name: Log No Issues Found
        if: steps.extract.outputs.found == 'false'
        run: |
          echo "‚ÑπÔ∏è  No issue numbers found in PR title, description, or commit messages"
          echo "üí° Tip: Reference issues with:"
          echo "   - Same repo: #123"
          echo "   - Cross repo: owner/repo#123"
          echo "Skipping issue linking - this is expected if PR doesn't reference any issues"
