name: Link Issues to Pull Request Post Merge

on:
  workflow_call:
    inputs:
      issue-pattern:
        description: "Custom regex pattern for matching issue numbers (optional)"
        required: false
        type: string
        default: '#(\d+)'
      max-commits:
        description: "Maximum number of commits to scan per page (default: 100)"
        required: false
        type: number
        default: 100

permissions: {}

jobs:
  link-issues:
    runs-on: ubuntu-latest

    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Extract Issue Numbers
        id: extract
        uses: actions/github-script@v7
        env:
          INPUT_ISSUE_PATTERN: ${{ inputs.issue-pattern }}
          INPUT_MAX_COMMITS: ${{ inputs.max-commits }}
          INPUT_MAX_BODY_LENGTH: ${{ inputs.max-body-length }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title || '';
            let body = pr.body || '';

            // Safely read inputs from environment variables (no template expansion)
            const rawMaxCommits = parseInt(process.env.INPUT_MAX_COMMITS || '100', 10);
            const maxCommits = Math.max(1, Math.min(Math.floor(rawMaxCommits), 100));

            if (rawMaxCommits !== maxCommits) {
              console.log(`‚ö†Ô∏è  max-commits adjusted from ${rawMaxCommits} to ${maxCommits} (valid range: 1-100)`);
            }

            // Validate and sanitize max body length
            const rawMaxBodyLength = parseInt(process.env.INPUT_MAX_BODY_LENGTH || '65536', 10);
            const maxBodyLength = Math.max(1024, Math.min(Math.floor(rawMaxBodyLength), 65536));

            if (rawMaxBodyLength !== maxBodyLength) {
              console.log(`‚ö†Ô∏è  max-body-length adjusted from ${rawMaxBodyLength} to ${maxBodyLength} (valid range: 1024-65536)`);
            }

            // Truncate body if too long to prevent memory issues
            if (body.length > maxBodyLength) {
              console.log(`‚ö†Ô∏è  PR body truncated from ${body.length} to ${maxBodyLength} characters`);
              body = body.substring(0, maxBodyLength);
            }

            let allCommits = [];
            let commitMessagesArray = [];
            let commitFetchError = null;

            try {
              let page = 1;
              let hasMore = true;
              const startTime = Date.now();
              const timeoutMs = 30000; // 30 second timeout for commit fetching

              console.log('=== Fetching commits ===');

              while (hasMore && allCommits.length < 250) {
                // Check timeout
                if (Date.now() - startTime > timeoutMs) {
                  console.log('‚ö†Ô∏è  Commit fetching timeout reached (30s). Proceeding with fetched commits.');
                  break;
                }

                const commits = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: maxCommits,
                  page: page
                });

                if (commits.data.length === 0) {
                  hasMore = false;
                } else {
                  allCommits = allCommits.concat(commits.data);
                  console.log(`Fetched page ${page}: ${commits.data.length} commits`);

                  if (commits.data.length < maxCommits) {
                    hasMore = false;
                  } else {
                    page++;
                  }
                }
              }

              // Extract commit messages with size validation
              let totalMessageLength = 0;
              const maxTotalMessageLength = 500000; // 500KB limit for all commit messages

              for (const commit of allCommits) {
                const message = commit.commit.message || '';
                if (totalMessageLength + message.length > maxTotalMessageLength) {
                  console.log(`‚ö†Ô∏è  Commit messages truncated at ${totalMessageLength} chars (${allCommits.length} commits processed)`);
                  break;
                }
                commitMessagesArray.push(message);
                totalMessageLength += message.length;
              }

              console.log(`Total commits scanned: ${commitMessagesArray.length}`);
              console.log(`Total message size: ${totalMessageLength} characters`);

              if (allCommits.length >= 250) {
                core.warning('‚ö†Ô∏è  Reached 250 commit limit. Some commits may not be scanned.');
              }

            } catch (error) {
              commitFetchError = error.message;
              core.warning(`Failed to fetch commits: ${error.message}. Continuing with PR title and description only.`);
              console.error('‚ùå Error fetching commits:', error.message);
              // Don't fail - we can still process title and body
            }

            // Combine all searchable text efficiently
            const searchParts = [title, body, ...commitMessagesArray];
            const searchText = searchParts.join('\n');

            console.log('=== Searching in ===');
            console.log('PR Title:', title);
            console.log('PR Body length:', body.length, 'chars');
            console.log('Commits scanned:', commitMessagesArray.length);
            if (commitFetchError) {
              console.log('Commit fetch error:', commitFetchError);
            }
            console.log('---');

            // Enhanced regex pattern validation with comprehensive ReDoS detection
            let validatedPattern = '#(\\d+)'; // Safe default
            const customPattern = (process.env.INPUT_ISSUE_PATTERN || '#(\\d+)').trim();

            if (customPattern && customPattern !== '#(\\d+)') {
              console.log('Validating custom issue pattern...');

              // Comprehensive ReDoS pattern detection
              const reDoSPatterns = [
                { pattern: /\(\?\#/, name: 'comment injection' },
                { pattern: /\(\?[<>=!]/, name: 'complex lookaround' },
                { pattern: /\{[0-9]+,\s*\}\+/, name: 'unbounded nested quantifier' },
                { pattern: /\(\.\*\)\+/, name: 'catastrophic backtracking (.*)+' },
                { pattern: /\(\.\*\)\*/, name: 'catastrophic backtracking (.*)*)' },
                { pattern: /\([^)]*\+[^)]*\)\+/, name: 'nested plus quantifiers' },
                { pattern: /\([^)]*\*[^)]*\)\*/, name: 'nested star quantifiers' },
                { pattern: /\([^)]*\+[^)]*\)\*/, name: 'nested mixed quantifiers' },
                { pattern: /\([^)]*\|[^)]*\)\+/, name: 'alternation with quantifier' },
                { pattern: /\([^)]*\|[^)]*\)\*/, name: 'alternation with star' },
                { pattern: /\\w\+\\s\*\+/, name: 'word-space quantifier combo' },
                { pattern: /\[[^\]]{50,}\]/, name: 'excessive character class' },
              ];

              let isPatternSafe = true;
              let rejectionReason = '';

              // Check against known dangerous patterns
              for (const check of reDoSPatterns) {
                if (check.pattern.test(customPattern)) {
                  console.log(`‚ùå Pattern rejected: ${check.name}`);
                  isPatternSafe = false;
                  rejectionReason = check.name;
                  break;
                }
              }

              // Additional length check
              if (customPattern.length > 200) {
                console.log('‚ùå Pattern rejected: exceeds 200 characters');
                isPatternSafe = false;
                rejectionReason = 'exceeds length limit';
              }

              // Test compilation with timeout
              if (isPatternSafe) {
                try {
                  const testRegex = new RegExp(customPattern, 'g');

                  // Test against known problematic strings with timeout simulation
                  const testStrings = [
                    'a'.repeat(100),
                    '#'.repeat(100),
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab',
                  ];

                  const testStart = Date.now();
                  for (const testStr of testStrings) {
                    if (Date.now() - testStart > 100) {
                      throw new Error('Pattern test timeout');
                    }
                    testRegex.test(testStr);
                  }

                  validatedPattern = customPattern;
                  console.log('‚úÖ Custom issue pattern validated and applied');
                } catch (e) {
                  console.log(`‚ùå Pattern validation failed: ${e.message}`);
                  isPatternSafe = false;
                  rejectionReason = e.message;
                }
              }

              if (!isPatternSafe) {
                core.warning(`Custom issue-pattern rejected (${rejectionReason}). Using default pattern.`);
              }
            }

            // Pattern for same-repo issues with timeout protection
            let sameRepoMatches = [];
            try {
              const sameRepoRegex = new RegExp(validatedPattern, 'g');
              const regexStart = Date.now();
              const regexTimeout = 5000; // 5 second timeout for regex operations

              sameRepoMatches = [...searchText.matchAll(sameRepoRegex)];

              if (Date.now() - regexStart > regexTimeout) {
                throw new Error('Regex execution timeout');
              }
            } catch (error) {
              core.setFailed(`Regex execution failed: ${error.message}`);
              return;
            }

            // Pattern for cross-repo issues with explicit bounds
            // Bounds: owner(1-39), repo(1-100), issue(1-10 digits)
            const crossRepoRegex = /\b([a-zA-Z0-9_-]{1,39}\/[a-zA-Z0-9_-]{1,100}#\d{1,10})\b/g;

            let crossRepoMatches = [];
            try {
              const regexStart = Date.now();
              crossRepoMatches = [...searchText.matchAll(crossRepoRegex)];

              if (Date.now() - regexStart > 1000) {
                core.warning('Cross-repo regex took longer than expected');
              }
            } catch (error) {
              core.setFailed(`Cross-repo regex failed: ${error.message}`);
              return;
            }

            // Extract issues (keep full match format)
            const sameRepoIssues = sameRepoMatches.map(m => m[0]); // Full match: #123
            const crossRepoIssues = crossRepoMatches.map(m => m[1]); // Capture group: owner/repo#123

            // Combine and deduplicate
            const allIssues = [...new Set([...sameRepoIssues, ...crossRepoIssues])];

            if (allIssues.length === 0) {
              console.log('‚ùå No issue numbers found in PR title, description, or commit messages');
              console.log('Note: Issue numbers must be prefixed with # (e.g., #123 or owner/repo#123)');
              core.setOutput('found', 'false');
              core.setOutput('issues', '');
              return;
            }

            console.log(`‚úÖ Found ${allIssues.length} issue reference(s):`);
            if (sameRepoIssues.length > 0) {
              console.log(`   Same repo (${sameRepoIssues.length}): ${[...new Set(sameRepoIssues)].join(', ')}`);
            }
            if (crossRepoIssues.length > 0) {
              console.log(`   Cross repo (${crossRepoIssues.length}): ${[...new Set(crossRepoIssues)].join(', ')}`);
            }

            core.setOutput('found', 'true');
            // Use newline-separated output to avoid injection via template expansion
            core.setOutput('issues', allIssues.join('\n'));

      - name: Update PR Description
        id: update-pr
        if: steps.extract.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          ISSUES_OUTPUT: ${{ steps.extract.outputs.issues }}
        with:
          script: |
            const pr = context.payload.pull_request;

            // Safely read issues from environment variable (no template expansion)
            let issues = [];
            try {
              const issuesOutput = process.env.ISSUES_OUTPUT || '';
              if (!issuesOutput || issuesOutput.trim() === '') {
                console.log('‚ö†Ô∏è  No issues data received');
                return;
              }

              issues = issuesOutput.split('\n').filter(i => i.trim());

              if (!Array.isArray(issues) || issues.length === 0) {
                console.log('‚ö†Ô∏è  Issues array is empty');
                return;
              }

              // Validate issue format to prevent injection
              const issuePattern = /^(#\d+|[a-zA-Z0-9_-]{1,39}\/[a-zA-Z0-9_-]{1,100}#\d{1,10})$/;
              const validIssues = issues.filter(issue => issuePattern.test(issue));

              if (validIssues.length !== issues.length) {
                core.warning(`Filtered ${issues.length - validIssues.length} invalid issue references`);
                issues = validIssues;
              }

              if (issues.length === 0) {
                console.log('‚ö†Ô∏è  No valid issues after filtering');
                return;
              }
            } catch (e) {
              core.setFailed(`Failed to parse issues: ${e.message}`);
              return;
            }

            try {
              // Get current PR body
              let body = pr.body || '';

              // Enhanced duplicate detection - check for existing "Resolves" sections
              // and also check if these specific issues are already mentioned
              const resolvesHeaderPattern = /^#{1,6}\s*Resolves/mi;

              if (resolvesHeaderPattern.test(body)) {
                console.log('‚ö†Ô∏è  PR description already contains a "Resolves" section');

                // Check if all our issues are already in the body
                const allIssuesAlreadyPresent = issues.every(issue => {
                  const escapedIssue = issue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                  const issuePattern = new RegExp(`Resolves\\s+${escapedIssue}\\b`, 'i');
                  return issuePattern.test(body);
                });

                if (allIssuesAlreadyPresent) {
                  console.log('‚úì All issues already resolved in PR description');
                  return 'skipped-all-present';
                }

                console.log('‚ö†Ô∏è  Some new issues to add, but "Resolves" section exists');
                console.log('Skipping to avoid creating duplicate sections');
                core.warning('PR already has Resolves section. Manual review recommended for new issues.');
                return 'skipped-section-exists';
              }

              // Build the resolves text
              // Issues already have correct format: "#123" or "owner/repo#123"
              const resolvesLines = issues.map(issue => `Resolves ${issue}`);
              const resolvesText = resolvesLines.join('\n');

              // Append to existing body with proper spacing
              const separator = body.trim() ? '\n\n---\n\n' : '';
              const updatedBody = `${body}${separator}${resolvesText}`;

              // Validate final body length
              if (updatedBody.length > 65536) {
                core.setFailed('Updated PR body would exceed GitHub limit (65536 chars)');
                return 'failed-too-long';
              }

              // Update the PR with retry logic
              let updateSuccess = false;
              let lastError = null;

              for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    body: updatedBody
                  });
                  updateSuccess = true;
                  break;
                } catch (error) {
                  lastError = error;
                  if (attempt < 3) {
                    console.log(`‚ö†Ô∏è  Update attempt ${attempt} failed, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                  }
                }
              }

              if (!updateSuccess) {
                core.setFailed(`Failed to update PR after 3 attempts: ${lastError.message}`);
                return 'failed-update-error';
              }

              console.log(`‚úÖ Updated PR #${pr.number} with:`);
              issues.forEach(issue => console.log(`   - Resolves ${issue}`));
              console.log(`üìã Total issues linked: ${issues.length}`);

              return 'success';

            } catch (error) {
              core.setFailed(`Failed to update PR: ${error.message}`);
              return 'failed-exception';
            }

      - name: Log No Issues Found
        if: steps.extract.outputs.found == 'false'
        run: |
          echo "‚ÑπÔ∏è  No issue numbers found in PR title, description, or commit messages"
          echo "üí° Tip: Reference issues with:"
          echo "   - Same repo: #123"
          echo "   - Cross repo: owner/repo#123"
          echo "Skipping issue linking - this is expected if PR doesn't reference any issues"
